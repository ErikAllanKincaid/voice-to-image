<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Voice to Image</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a2e;
      color: #eee;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 2rem;
    }
    h1 { margin-bottom: 1.5rem; color: #a0c4ff; }
    .container {
      max-width: 600px;
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1.5rem;
    }
    .record-btn {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      border: 4px solid #a0c4ff;
      background: #16213e;
      color: #a0c4ff;
      font-size: 1rem;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .record-btn:hover { background: #1a2744; transform: scale(1.05); }
    .record-btn.recording {
      border-color: #ff6b6b;
      background: #4a1a1a;
      color: #ff6b6b;
      animation: pulse 1s infinite;
    }
    .record-btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .mode-toggle { display: flex; gap: 1rem; align-items: center; }
    .continuous-btn {
      padding: 1rem 1.5rem;
      border-radius: 8px;
      border: 2px solid #77dd77;
      background: #16213e;
      color: #77dd77;
      font-size: 1rem;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
    }
    .continuous-btn:hover { background: #1a2744; }
    .continuous-btn.running {
      border-color: #ff6b6b;
      color: #ff6b6b;
      animation: pulse 2s infinite;
    }
    .continuous-btn:disabled { opacity: 0.5; cursor: not-allowed; }
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    .status {
      text-align: center;
      min-height: 3rem;
      color: #888;
    }
    .status.error { color: #ff6b6b; }
    .result {
      width: 100%;
      display: none;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
    }
    .result.visible { display: flex; }
    .result img {
      max-width: 100%;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.4);
    }
    .meta {
      background: #16213e;
      padding: 1rem;
      border-radius: 8px;
      width: 100%;
      font-size: 0.9rem;
    }
    .meta-label { color: #a0c4ff; font-weight: bold; margin-bottom: 0.3rem; }
    .meta-value { color: #ccc; margin-bottom: 1rem; }
    .meta-value:last-child { margin-bottom: 0; }
    .options {
      background: #16213e;
      padding: 1rem;
      border-radius: 8px;
      width: 100%;
    }
    .options label { display: block; margin-bottom: 0.5rem; color: #a0c4ff; }
    .options input[type="text"] {
      width: 100%;
      padding: 0.5rem;
      border: 1px solid #333;
      border-radius: 4px;
      background: #0f0f23;
      color: #eee;
    }
    .options .checkbox-row {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Voice to Image</h1>

    <div class="mode-toggle">
      <button id="recordBtn" class="record-btn">Hold to Record</button>
      <button id="continuousBtn" class="continuous-btn">Start Continuous</button>
    </div>
    <div id="status" class="status">Press and hold to record, or start continuous mode</div>

    <div class="options">
      <label>Chromecast Device</label>
      <input type="text" id="device" placeholder="Leave empty for default" value="Living Room TV">
      <div class="checkbox-row">
        <input type="checkbox" id="castEnabled" checked>
        <label for="castEnabled" style="margin:0">Cast to Chromecast</label>
      </div>
      <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #333;">
        <label>Model Quality</label>
        <select id="modelPreset" style="width: 100%; padding: 0.5rem; background: #0f0f23; color: #eee; border: 1px solid #333; border-radius: 4px; margin-top: 0.3rem;">
          <option value="lite">Lite (fastest, ~4GB)</option>
          <option value="standard" selected>Standard (~6GB)</option>
          <option value="high">High - SDXL-Turbo (~10GB)</option>
          <option value="ultra">Ultra - SDXL 30 steps (~24GB)</option>
          <option value="flux">FLUX.1 (~24GB or 2x12GB)</option>
        </select>
      </div>
      <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #333;">
        <label>Image Size (16:9)</label>
        <select id="imageSize" style="width: 100%; padding: 0.5rem; background: #0f0f23; color: #eee; border: 1px solid #333; border-radius: 4px; margin-top: 0.3rem;">
          <option value="640x360">640x360 (Lite)</option>
          <option value="768x432" selected>768x432 (Fast)</option>
          <option value="1024x576">1024x576 (Medium)</option>
          <option value="1280x720">1280x720 (HD)</option>
        </select>
      </div>
      <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #333;">
        <label>Image Style</label>
        <select id="imageStyle" style="width: 100%; padding: 0.5rem; background: #0f0f23; color: #eee; border: 1px solid #333; border-radius: 4px; margin-top: 0.3rem;">
          <option value="random" selected>ðŸŽ² Random</option>
          <option value="">Auto (LLM chooses)</option>
          <optgroup label="Realistic">
            <option value="photorealistic photograph">Photorealistic</option>
            <option value="cinematic film still, dramatic lighting">Cinematic</option>
            <option value="documentary photography style">Documentary</option>
          </optgroup>
          <optgroup label="Artistic">
            <option value="digital art, vibrant colors">Digital Art</option>
            <option value="oil painting, textured brushstrokes">Oil Painting</option>
            <option value="watercolor painting, soft edges">Watercolor</option>
            <option value="impressionist painting style">Impressionist</option>
            <option value="pencil sketch, detailed linework">Pencil Sketch</option>
          </optgroup>
          <optgroup label="Stylized">
            <option value="anime style, cel shaded">Anime</option>
            <option value="comic book art, bold lines">Comic Book</option>
            <option value="pixel art, retro game style">Pixel Art</option>
            <option value="3D render, octane render">3D Render</option>
            <option value="low poly 3D art">Low Poly</option>
          </optgroup>
          <optgroup label="Mood/Genre">
            <option value="fantasy art, magical atmosphere">Fantasy</option>
            <option value="cyberpunk style, neon lights">Cyberpunk</option>
            <option value="film noir, black and white, dramatic shadows">Noir</option>
            <option value="vintage retro style, 1970s aesthetic">Vintage</option>
            <option value="surrealist art, dreamlike">Surrealist</option>
          </optgroup>
        </select>
      </div>
      <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #333;">
        <label>Continuous Mode Settings</label>
        <div style="display: flex; gap: 1rem; margin-top: 0.5rem;">
          <div>
            <label style="font-size: 0.8rem; color: #888;">Record (sec)</label>
            <input type="number" id="recordDuration" value="5" min="2" max="30" style="width: 70px;">
          </div>
          <div>
            <label style="font-size: 0.8rem; color: #888;">Interval (sec)</label>
            <input type="number" id="interval" value="60" min="10" max="600" style="width: 70px;">
          </div>
        </div>
      </div>
    </div>

    <div id="result" class="result">
      <img id="resultImg" src="" alt="Generated image">
      <div class="meta">
        <div class="meta-label">You said:</div>
        <div class="meta-value" id="transcription"></div>
        <div class="meta-label">Image prompt:</div>
        <div class="meta-value" id="prompt"></div>
      </div>
    </div>
  </div>

  <script>
    const recordBtn = document.getElementById('recordBtn');
    const continuousBtn = document.getElementById('continuousBtn');
    const status = document.getElementById('status');
    const result = document.getElementById('result');
    const resultImg = document.getElementById('resultImg');
    const transcriptionEl = document.getElementById('transcription');
    const promptEl = document.getElementById('prompt');
    const deviceInput = document.getElementById('device');
    const castEnabled = document.getElementById('castEnabled');
    const modelPresetSelect = document.getElementById('modelPreset');
    const imageSizeSelect = document.getElementById('imageSize');
    const imageStyleSelect = document.getElementById('imageStyle');

    // Style options for random selection (excludes "random" and "auto" options)
    const styleOptions = [
      "photorealistic photograph",
      "cinematic film still, dramatic lighting",
      "documentary photography style",
      "digital art, vibrant colors",
      "oil painting, textured brushstrokes",
      "watercolor painting, soft edges",
      "impressionist painting style",
      "pencil sketch, detailed linework",
      "anime style, cel shaded",
      "comic book art, bold lines",
      "pixel art, retro game style",
      "3D render, octane render",
      "low poly 3D art",
      "fantasy art, magical atmosphere",
      "cyberpunk style, neon lights",
      "film noir, black and white, dramatic shadows",
      "vintage retro style, 1970s aesthetic",
      "surrealist art, dreamlike"
    ];

    function getSelectedStyle() {
      const val = imageStyleSelect.value;
      if (val === 'random') {
        return styleOptions[Math.floor(Math.random() * styleOptions.length)];
      }
      return val;
    }
    const recordDurationInput = document.getElementById('recordDuration');
    const intervalInput = document.getElementById('interval');

    let mediaRecorder = null;
    let audioChunks = [];
    let isRecording = false;
    let continuousMode = false;
    let continuousTimeout = null;

    async function startRecording() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
        audioChunks = [];

        mediaRecorder.ondataavailable = (e) => {
          if (e.data.size > 0) audioChunks.push(e.data);
        };

        mediaRecorder.onstop = async () => {
          stream.getTracks().forEach(t => t.stop());
          if (audioChunks.length > 0) {
            await processAudio();
          }
        };

        mediaRecorder.start(100);
        isRecording = true;
        recordBtn.classList.add('recording');
        recordBtn.textContent = 'Recording...';
        status.textContent = 'Listening...';
        status.classList.remove('error');
      } catch (err) {
        console.error('Mic error:', err);
        if (err.name === 'NotAllowedError') {
          status.textContent = 'Microphone access denied - click lock icon in address bar to allow';
        } else if (err.name === 'NotFoundError') {
          status.textContent = 'No microphone found';
        } else if (err.name === 'NotSupportedError' || err.name === 'SecurityError') {
          status.textContent = 'Mic requires HTTPS or localhost - use http://localhost:8766';
        } else {
          status.textContent = `Mic error: ${err.message}`;
        }
        status.classList.add('error');
      }
    }

    function stopRecording() {
      if (mediaRecorder && isRecording) {
        mediaRecorder.stop();
        isRecording = false;
        recordBtn.classList.remove('recording');
        recordBtn.textContent = 'Hold to Record';
      }
    }

    async function timedRecording(durationSec) {
      return new Promise(async (resolve, reject) => {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          const recorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
          const chunks = [];

          recorder.ondataavailable = (e) => {
            if (e.data.size > 0) chunks.push(e.data);
          };

          recorder.onstop = () => {
            stream.getTracks().forEach(t => t.stop());
            resolve(chunks);
          };

          recorder.start(100);
          setTimeout(() => recorder.stop(), durationSec * 1000);
        } catch (err) {
          reject(err);
        }
      });
    }

    async function continuousCycle() {
      if (!continuousMode) return;

      const duration = parseInt(recordDurationInput.value) || 5;
      const interval = parseInt(intervalInput.value) || 60;

      status.textContent = `Recording for ${duration}s...`;
      recordBtn.disabled = true;

      try {
        const chunks = await timedRecording(duration);
        if (chunks.length > 0 && continuousMode) {
          audioChunks = chunks;
          await processAudio();
        }
      } catch (err) {
        console.error('Continuous recording error:', err);
        status.textContent = `Error: ${err.message}`;
        status.classList.add('error');
      }

      recordBtn.disabled = false;

      if (continuousMode) {
        status.textContent = `Next recording in ${interval}s...`;
        continuousTimeout = setTimeout(continuousCycle, interval * 1000);
      }
    }

    function toggleContinuousMode() {
      continuousMode = !continuousMode;

      if (continuousMode) {
        continuousBtn.textContent = 'Stop Continuous';
        continuousBtn.classList.add('running');
        recordBtn.disabled = true;
        continuousCycle();
      } else {
        continuousBtn.textContent = 'Start Continuous';
        continuousBtn.classList.remove('running');
        recordBtn.disabled = false;
        if (continuousTimeout) {
          clearTimeout(continuousTimeout);
          continuousTimeout = null;
        }
        status.textContent = 'Continuous mode stopped';
      }
    }

    async function processAudio() {
      status.textContent = 'Processing...';
      recordBtn.disabled = true;

      // Convert webm to wav
      const webmBlob = new Blob(audioChunks, { type: 'audio/webm' });
      const wavBlob = await convertToWav(webmBlob);

      const formData = new FormData();
      formData.append('audio', wavBlob, 'recording.wav');
      formData.append('cast', castEnabled.checked ? 'true' : 'false');
      formData.append('device', deviceInput.value);
      formData.append('preset', modelPresetSelect.value);
      formData.append('size', imageSizeSelect.value);
      formData.append('style', getSelectedStyle());

      try {
        const resp = await fetch('/api/pipeline', {
          method: 'POST',
          body: formData,
        });

        if (!resp.ok) {
          const err = await resp.json();
          throw new Error(err.error || 'Server error');
        }

        const imageBlob = await resp.blob();
        const imageUrl = URL.createObjectURL(imageBlob);

        resultImg.src = imageUrl;
        transcriptionEl.textContent = resp.headers.get('X-Transcription') || '(unknown)';
        promptEl.textContent = resp.headers.get('X-Prompt') || '(unknown)';
        result.classList.add('visible');

        status.textContent = 'Done!';
      } catch (err) {
        status.textContent = err.message;
        status.classList.add('error');
      } finally {
        recordBtn.disabled = false;
      }
    }

    async function convertToWav(webmBlob) {
      const audioContext = new AudioContext({ sampleRate: 16000 });
      const arrayBuffer = await webmBlob.arrayBuffer();
      const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

      // Get mono channel
      const channelData = audioBuffer.getChannelData(0);

      // Create WAV
      const wavBuffer = encodeWav(channelData, 16000);
      return new Blob([wavBuffer], { type: 'audio/wav' });
    }

    function encodeWav(samples, sampleRate) {
      const buffer = new ArrayBuffer(44 + samples.length * 2);
      const view = new DataView(buffer);

      // WAV header
      writeString(view, 0, 'RIFF');
      view.setUint32(4, 36 + samples.length * 2, true);
      writeString(view, 8, 'WAVE');
      writeString(view, 12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, 1, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * 2, true);
      view.setUint16(32, 2, true);
      view.setUint16(34, 16, true);
      writeString(view, 36, 'data');
      view.setUint32(40, samples.length * 2, true);

      // Convert float32 to int16
      let offset = 44;
      for (let i = 0; i < samples.length; i++) {
        const s = Math.max(-1, Math.min(1, samples[i]));
        view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
        offset += 2;
      }

      return buffer;
    }

    function writeString(view, offset, string) {
      for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
      }
    }

    // Event listeners - hold to record
    recordBtn.addEventListener('mousedown', startRecording);
    recordBtn.addEventListener('mouseup', stopRecording);
    recordBtn.addEventListener('mouseleave', stopRecording);
    recordBtn.addEventListener('touchstart', (e) => { e.preventDefault(); startRecording(); });
    recordBtn.addEventListener('touchend', stopRecording);

    // Continuous mode toggle
    continuousBtn.addEventListener('click', toggleContinuousMode);

    // Check mic permission on load
    navigator.permissions?.query({ name: 'microphone' }).then(result => {
      if (result.state === 'denied') {
        status.textContent = 'Microphone blocked - click lock icon in address bar to allow';
        status.classList.add('error');
      }
    }).catch(() => {});

    // Check server health on load
    fetch('/api/health')
      .then(r => r.json())
      .then(data => {
        if (data.status === 'ok') {
          status.textContent = `Server ready (GPU: ${data.gpu ? 'yes' : 'no'})`;
        }
      })
      .catch(() => {
        status.textContent = 'Server not available - start it with: uv run python server.py';
        status.classList.add('error');
      });
  </script>
</body>
</html>
